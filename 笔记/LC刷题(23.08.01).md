# LeetCode136. 只出现一次的数字Ⅰ

- **题目**: 
> 给你一个 非空 整数数组 `nums` ，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。[OJ链接](https://leetcode.cn/problems/single-number/)

- **要求**
> 你必须设计并实现线性时间复杂度的算法来解决此问题，且该算法只使用常量额外空间。

- **思路**
<font color='red'>位运算:异或运算</font>
    - `a ^ 0 = a`
    - `a ^ a = 0`
    - `a ^ b ^ a = b`
> 定义一个变量`x = 0`,将数组所有的元素进行异或运算,结果即是单独的数字

- **实例**
> 输入：nums = [2,2,1]
输出：1

`2 ^ 2 ^ 1 = 1`

- **代码实现**
```c
int singleNumber(int* nums, int numsSize)
{
    int x = 0;
    int i = 0;

    for (i = 0; i < numsSize; i++)
    {
        x ^= nums[i];
    }

    return x;
}
```
# LeetCode137. 只出现一次的数字 II

- **题目**
> 给你一个整数数组 nums ，除某个元素仅出现 **一次** 外，其余每个元素都恰出现 三次 。请你找出并返回那个只出现了一次的元素。[OJ链接](https://leetcode.cn/problems/single-number-ii/description/)

- **要求**
> 你必须设计并实现线性时间复杂度的算法且不使用额外空间来解决此问题。

- **思路**
<font color='red'>位运算:与运算</font>
    - `(a >> 0) & 1`得到最后一位
    - `(a >> 1) & 1`得到倒数第二位
    - `(a >> 2) & 1`得到倒数第三位
    - ...
> `int`类型有 32 位,将数组所有元素按位相加,得到的结果模 3 即 单个元素在该位的数

> 注意: 在c语言中, `int`类型被规定左移位数 (`i >= 0 && i < 31`).而`unsigned int`类型被规定左移数 (`i >=0 && i <= 31`).因此需要使用无符号数`1u`

- **实例**
> 输入：nums = [2,2,3,2]
输出：3

![1690875982210](image/LC刷题(23.08.01)/1690875982210.png)
- **代码实现**
```c
int singleNumber(int* nums, int numsSize)
{
    int x = 0;
    int i = 0;
    int j = 0;
    
    for (i = 0; i < 32; i++)
    {
        int sum_bit = 0;    //记录数组所有第i位的和

        for (j = 0; j < numsSize; j++)
        {
            sum_bit += (nums[j] >> i) & 1;
        }

        if (sum_bit % 3)    //如果不能整除3,单个元素在第 i 位有 1
        {
            x |= 1u << i;
        }
    }

    return x;
}
```

# LeetCode260. 只出现一次的数字 III

- **题目**
> 给你一个整数数组 `nums`，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两个元素。你可以按 **任意顺序** 返回答案。[OJ链接](https://leetcode.cn/problems/single-number-iii/description/)

- **要求**
> 你必须设计并实现线性时间复杂度的算法且仅使用常量额外空间来解决此问题。

- **思路**
<font color='red'>位运算: 异或运算 和 与运算</font>
> 1. 得到两个数的异或结果 `xornum`
> 2. 取到 `xornum` 第 `xorbit` 为 1 的数, 只要一个即可
> 3. 数组所有元素分成两组, 第 `xorbit` 位为 1 分成一组, 第 `xorbit` 位为 0 分成一组
> 4. 每组元素全部异或,两组的两个异或结果即为两个单独元素

- **实例**
> 输入：nums = [1,2,1,3,2,5]
输出：[3,5]
解释：[5, 3] 也是有效的答案。

![1690876345455](image/LC刷题(23.08.01)/1690876345455.png)
- **代码实现**
```c
int* singleNumber(int* nums, int numsSize, int* returnSize)
{
    int *ret = (int*)calloc(sizeof(int), 2);    //存放两个数的数组
    int xornum = 0;          //存放两个数的异或结果
    int i = 0;
    int xorbit = 0;

    //先得到两个数的异或结果
    for (i = 0; i < numsSize; i++)
    {
        xornum ^= nums[i];
    }

    //找到异或结果中是 1 的一位,说明这两个数在这一位一个是 1, 一个是0
    for (i = 0; i < 31; i++)    //int类型最多左移30位
    {
        if ((xornum >> i) & 1 == 1)
        {
            xorbit = i;
            break;
        }
    }

    //随后将数组元素进行分组: 元素在该位是 1 分一组;元素在该位是 0 分一组
    //同时将每组元素进行异或, 得到结果

    for (i = 0; i < numsSize; i++)
    {
        if ((nums[i] >> xorbit) & 1 == 1)
        {
            ret[0] ^= nums[i];
        }
        else
        {
            ret[1] ^= nums[i];
        }
    }
    
    *returnSize = 2;
    return ret;
}
```
# LeetCode268. 丢失的数字
- **题目**
> 给定一个包含 `[0, n]` 中 `n` 个数的数组 `nums` ，找出 `[0, n]` 这个范围内没有出现在数组中的那个数。

- **思路**
<font color='red'>位运算: 异或运算</font>
> 数组所有元素 和 `[0, n]` 一起异或, 异或结果为丢失的数字
> 实际也是单身狗思路
- **实例**
> 输入：nums = [3,0,1]
输出：2
解释：n = 3，因为有 3 个数字，所以所有的数字都在范围 [0,3] 内。2 是丢失的数字，因为它没有出现在 nums 中。

> `[3,0,1]` 和 `[0, 3]` 所有元素异或, 可以理解为找出 `[0,0,1,1,2,3,3]` 中仅出现一次的数字

- **代码实现**
```c
int missingNumber(int* nums, int numsSize)
{
    int i = 0;
    int xornum = 0;

    //先得到 [0, n] 的异或结果
    for (i = 0; i <= numsSize; i++)
    {
        xornum ^= i;
    }

    //再将异或结果与数组所有元素异或
    for (i = 0; i < numsSize; i++)
    {
        xornum ^= nums[i];
    }

    return xornum;
}
```
# LeetCode27. 移除元素
- **题目**
> 给你一个数组 `nums` 和一个值 `val`，你需要 **原地** 移除所有数值等于 `val` 的元素，并返回移除后数组的新长度。[OJ链接](https://leetcode.cn/problems/remove-element/)

- **要求**
> 不要使用额外的数组空间，你必须仅使用 $O(1)$ 额外空间并 **原地** 修改输入数组。

> 元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。

- **思路**
<font color='red'>双指针</font>
> 1. 定义两个指针 `dest` 和 `src`
> 2. `src` 遍历数组, 如果有不为 `val` 的元素, 放置 `dest` 指向的空间, 同时 `dest++`
> 3. 数组的长度即为 `dest - nums`

- **实例**
> 输入：nums = [3,2,2,3], val = 3
输出：2, nums = [2,2]
解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。

![1690880833507](image/LC刷题(23.08.01)/1690880833507.png)
- **代码实现**
```c
int removeElement(int* nums, int numsSize, int val)
{
    int* src = nums;    //用于遍历数组
    int* dest = nums;   //用于存储不等于 val 的元素

    while (src < nums + numsSize)   //循环条件: src 未到数组末尾
    {
        if (*src != val)    //如果该元素不等于 val
        {
            *dest++ = *src; //存储到 dest 指向的空间, 同时 dest 指向下一空间
        }
        src++;
    }
    
    return dest - nums; //返回数组长度
}
```

# LeetCode283. 移动零

- **题目**
> 给定一个数组 `nums`，编写一个函数将所有 `0` 移动到数组的末尾，同时保持非零元素的相对顺序。[OJ链接](https://leetcode.cn/problems/move-zeroes/description/)

- **要求**
> **请注意**，必须在不复制数组的情况下原地对数组进行操作

- **思路**
<font color='red'>双指针</font>
> 1. 定义两个指针 `dest` 和 `src`
> 2. `src` 遍历数组, 如果有不为 `val` 的元素, 放置 `dest` 指向的空间, 同时 `dest++`
> 3. 将 `dest`指向的剩余数组元素都置为 0
- **实例**
> 输入: nums = [0,1,0,3,12]
输出: [1,3,12,0,0]

![1690881339940](image/LC刷题(23.08.01)/1690881339940.png)
- **代码实现**
```c
void moveZeroes(int* nums, int numsSize)
{
    int* src = nums;    //用于遍历数组
    int* dest = nums;   //用于存储不等于 0 的元素

    //将不为 0 的元素顺序存储到数组前部分
    while (src < nums + numsSize)   //循环条件: src 未到数组末尾
    {
        if (*src != 0)    //如果该元素不等于 0
        {
            *dest++ = *src; //存储到 dest 指向的空间, 同时 dest 指向下一空间
        }
        src++;
    }

    //将 0 全放置数组后部分
    while (dest < nums + numsSize)
    {
        *dest++ = 0;
    }
}
```

# LeetCode26. 删除有序数组中的重复项 Ⅰ

- **题目**
> 给你一个 升序排列 的数组 `nums` ，请你 **原地** 删除重复出现的元素，使每个元素 **只出现一次** ，返回删除后数组的新长度。元素的 **相对顺序** 应该保持 **一致** 。然后返回 `nums `中唯一元素的个数。[OJ链接](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/)
- **要求**
>考虑 `nums` 的唯一元素的数量为 `k` ，你需要做以下事情确保你的题解可以被通过：
> 更改数组 `nums` ，使 `nums` 的前 `k` 个元素包含唯一元素，并按照它们最初在 `nums` 中出现的顺序排列。`nums` 的其余元素与 `nums` 的大小不重要。
返回 `k` 。
- **思路**
<font color='red'>双指针</font>
> 1. 定义两个指针 `dest` 和 `src`
> 2. `src` 遍历数组, 如果 `src` 和 `dest` 指向的元素不相等, `++dest`, 并把该元素存到 `dest` 指向的空间内
> 3. 数组长度是 `dest - nums + 1`

- **实例**
> 输入：nums = [1,1,2]
输出：2, nums = [1,2,_]
解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。

![1690882421318](image/LC刷题(23.08.01)/1690882421318.png)
- **代码实现**
```c
int removeDuplicates(int* nums, int numsSize)
{
    int* src = nums;    //用于遍历数组
    int* dest = nums;   //用于存储元素

    //将没有重复的元素放到数组前部分
    while (src < nums + numsSize)   //循环条件: src 未到数组末尾
    {
        if (*src != *dest)  //如果有不一致的数字
        {
            *(++dest) = *src;
        }
        src++;
    }

    return dest - nums + 1;
}
```
# LeetCode80. 删除有序数组中的重复项 II

- **题目**
> 给你一个有序数组 `nums` ，请你 **原地** 删除重复出现的元素，使得出现次数超过两次的元素只出现两次 ，返回删除后数组的新长度。[OJ链接](https://leetcode.cn/problems/remove-duplicates-from-sorted-array-ii/description/)
- **要求**
> 不要使用额外的数组空间，你必须在 **原地** **修改输入数组** 并在使用 $O(1)$ 额外空间的条件下完成。
- **思路**
<font color='red'>双指针</font>

> 1. 定义三个指针 `dest` , `src` 和 `same`
> 2. `src` 遍历数组, `dest`存储数据, `same`记录每次不相等的元素的位置
> 3. 如果 `src` 和 `same` 指向的空间相等, 且记录数小于 2, `*dest++ = *src++`
> 4. 如果 `src` 和 `same` 指向的空间不相等, 更新 `same`, 同时`*dest++ = *src++`, `count` 记为 1
> 5. 如果都不满足, 只有 `src++`
- **实例**
> 输入：nums = [1,1,1,2,2,3]
输出：5, nums = [1,1,2,2,3]
解释：函数应返回新长度 length = 5, 并且原数组的前五个元素被修改为 1, 1, 2, 2, 3 。 不需要考虑数组中超出新长度后面的元素。

![1690886454542](image/LC刷题(23.08.01)/1690886454542.png)
- **代码实现**
```c
int removeDuplicates(int* nums, int numsSize)
{
    int* src = nums;    //用于遍历数组
    int* dest = nums;   //用于存储元素
    int count = 0;

    //将没有重复的元素放到数组前部分
    while (src < nums + numsSize)   //循环条件: src 未到数组末尾
    {
        if (count < 2 && *src == *(same)) //如果连续相同个数小于2 并且 两元素相等
        {
            *dest++ = *src++;
            count++;
        }
        else if (*src != *same ) //如果两元素不相等
        {
            same = src;
            *dest++ = *src++;
            count = 1;
        }
        else
        {
            src++;
        }
    }

    return dest - nums;
}
```
# LeetCode88. 合并两个有序数组

- **题目**
> 给你两个按 **非递减顺序** 排列的整数数组 `nums1` 和 `nums2`，另有两个整数 `m` 和 `n` ，分别表示 `nums1` 和 `nums2` 中的元素数目。[OJ链接](https://leetcode-cn.com/problems/merge-sorted-array/)  

请你 **合并** `nums2` 到 `nums1` 中，使合并后的数组同样按 **非递减顺序** 排列。
- **要求**
> **注意**：最终，合并后数组不应由函数返回，而是存储在数组 `nums1` 中。为了应对这种情况，`nums1` 的初始长度为` m + n`，其中前 `m` 个元素表示应合并的元素，后 `n` 个元素为` 0` ，应忽略。`nums2` 的长度为 `n` 。
- **思路**
<font color='red'>逆向双指针</font>

> 1. 定义 `end1` 指向数组 1 有效元素的末尾, `end2` 指向数组 2 的末尾, `end`指向数组 1 的末尾
> 2. 从大至小,从后至前存放到数组 1 中
> 3. 如果是数组 2 没有遍历完, 直接从大至小存放到剩余空间

- **实例**
> 输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3
输出：[1,2,2,3,5,6]

![1690887591023](image/LC刷题(23.08.01)/1690887591023.png)
- **代码实现**
```c
void merge(int* nums1, int nums1Size, int m, int* nums2, int nums2Size, int n)
{
   int end1 = m - 1;    //指向数组1的最后元素
   int end2 = n - 1;    //指向数组2的最后元素
   int end = m + n - 1; //指向新数组的最后元素

   //从大到小存储到数组中
   while (end1 != -1 && end2 != -1)
   {
        if (nums1[end1] > nums2[end2])
        {
            nums1[end--] = nums1[end1--];
        }
        else
        {
            nums1[end--] = nums2[end2--];
        }
   }

   //如果nums2没有遍历完,将nums2剩余的元素拷贝到nums1
   while (end2 != -1)
   {
       nums1[end--] = nums2[end2--];
   }
}
```
- **题目**
- **要求**
- **思路**
- **实例**
- **代码实现**

